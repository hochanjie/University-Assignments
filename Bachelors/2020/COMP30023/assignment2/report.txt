Firstly, I decided to implement a Shortest Job First algorithm that prioritises processes with the shortest remaining time, which only works in batch environments, where the job time is known. It is good when there are a lot of medium and short processes back to back (as shown in my benchmark). This allows the CPU to minimise average wait time, as shown by the low average time overhead. However, it is not good when a lot of short jobs arrive in short succession after a long one, as the long job will never get CPU time (starvation).

Next, I implemented an Optimal Allocation algorithm that decides to evict the pages of the process at the very back of the schedule. This is good compared to choosing the least-recently run process, especially if that process was next in the queue, where it would then have to load its pages again. It protects against the trashing of the virtual memory, especially if there is a very long loading time or a lot of page faults happening (which can happen if there are a lot of processes). 
